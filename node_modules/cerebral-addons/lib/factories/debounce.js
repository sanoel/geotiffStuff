'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (time, continueChain) {
  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _ref$terminateChain = _ref.terminateChain;
  var terminateChain = _ref$terminateChain === undefined ? [] : _ref$terminateChain;
  var _ref$immediate = _ref.immediate;
  var immediate = _ref$immediate === undefined ? true : _ref$immediate;

  var id = Symbol('id');

  var timeout = function debounceTimeout() {
    if (pending[id].continue) {
      // continue the final signal
      pending[id].continue();
      // immediate debounce should wait until time before sending immediate again
      if (immediate) {
        pending[id] = {
          timeout: setTimeout(timeout, time)
        };
      } else {
        delete pending[id];
      }
    } else {
      // no pending signals
      delete pending[id];
    }
  };

  var debounce = function debounce(_ref2) {
    var output = _ref2.output;

    if (pending[id]) {
      // not first time
      if (pending[id].terminate) {
        // terminate the previous signal
        pending[id].terminate();
      }
      // replace previous signal with this one
      pending[id].continue = output.continue;
      pending[id].terminate = output.terminate;
    } else {
      // first time
      pending[id] = {
        timeout: setTimeout(timeout, time)
      };
      if (!immediate) {
        // queue the signal
        pending[id].continue = output.continue;
        pending[id].terminate = output.terminate;
      } else {
        // continue the signal
        output.continue();
      }
    }
  };

  debounce.outputs = ['continue', 'terminate'];

  debounce.displayName = 'addons.debounce(' + time + ', ...)';

  return [debounce, {
    continue: continueChain,
    terminate: terminateChain
  }];
};

var pending = {};